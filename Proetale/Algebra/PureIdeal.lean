/-
Copyright (c) 2026 Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christian Merten
-/
import Mathlib

/-!

# Pure ideals

An ideal `I` of a ring `R` is called pure if `R ⧸ I` is flat over `R`
(see [Stacks 04PR](https://stacks.math.columbia.edu/tag/04PR)).
We don't actually define this term, but use `Module.Flat R (R ⧸ I)` instead. In this file we show
some properties of such ideals.

## Main results and definitions

- `Ideal.inf_eq_mul_of_flat`: If `I` is pure, `I ⊓ J = I * J` for every ideal `J`.
- `Ideal.flat_of_inf_eq_mul`: If for any f.g. ideal `J`, the equality `I ⊓ J = I * J` holds, then
  `I` is pure.
- `Ideal.zeroLocus_inj_of_flat`: If `I` and `J` are pure ideals such that `V(I) = V(J)`, then
  `I = J`.

-/

variable {R : Type*} [CommRing R]

open TensorProduct

lemma Submodule.ker_mapQ {R : Type*} {M : Type*} [Ring R] [AddCommGroup M] [Module R M]
    (p : Submodule R M) {R₂ : Type*} {M₂ : Type*} [Ring R₂] [AddCommGroup M₂] [Module R₂ M₂]
    {τ₁₂ : R →+* R₂} (q : Submodule R₂ M₂) (f : M →ₛₗ[τ₁₂] M₂) (h : p ≤ Submodule.comap f q) :
    LinearMap.ker (p.mapQ q f h) = (Submodule.comap f q).map p.mkQ := by
  simp [Submodule.mapQ, Submodule.ker_liftQ, LinearMap.ker_comp]

@[simp]
lemma TensorProduct.quotTensorEquivQuotSMul_mk_one_tmul {R : Type*} (M : Type*) [CommRing R]
    [AddCommGroup M] [Module R M] (I : Ideal R) (x : M) :
    TensorProduct.quotTensorEquivQuotSMul M I (1 ⊗ₜ x) = Submodule.Quotient.mk x := by
  rw [← RingHom.map_one (Ideal.Quotient.mk I), TensorProduct.quotTensorEquivQuotSMul_mk_tmul]
  simp

lemma injective_lTensor_quotient_iff_inf_eq_mul (I J : Ideal R) :
    Function.Injective (J.subtype.lTensor (R ⧸ I)) ↔ I ⊓ J = I * J := by
  let f : J ⧸ (I • ⊤ : Submodule R J) →ₗ[R] R ⧸ I :=
    Submodule.mapQ _ _ J.subtype <| by
      simp [← Submodule.map_le_iff_le_comap, Ideal.mul_le_right]
  have : J.subtype.lTensor (R ⧸ I) =
      (TensorProduct.rid R (R ⧸ I)).symm ∘ₗ f ∘ₗ TensorProduct.quotTensorEquivQuotSMul J I := by
    ext
    simp [f, ← Ideal.Quotient.algebraMap_eq, Algebra.TensorProduct.tmul_one_eq_one_tmul]
  rw [this]
  simp only [LinearMap.coe_comp, LinearEquiv.coe_coe, EmbeddingLike.comp_injective,
    EquivLike.injective_comp, ← LinearMap.ker_eq_bot, f, Submodule.ker_mapQ,
    ← LinearMap.le_ker_iff_map, Submodule.ker_mkQ,
    ← (Submodule.map_le_map_iff_of_injective J.injective_subtype)]
  simp [inf_comm, le_antisymm_iff, Ideal.mul_le_inf (I := I) (J := J)]

@[stacks 04PS "(1) => (2)"]
lemma Ideal.inf_eq_mul_of_flat (I J : Ideal R) [Module.Flat R (R ⧸ I)] :
    I ⊓ J = I * J := by
  rw [← injective_lTensor_quotient_iff_inf_eq_mul]
  apply Module.Flat.lTensor_preserves_injective_linearMap
  exact J.injective_subtype

lemma Ideal.sq_eq_self (I : Ideal R) [Module.Flat R (R ⧸ I)] : I ^ 2 = I := by
  simp [sq, ← Ideal.inf_eq_mul_of_flat]

@[stacks 04PS "(3) => (1)"]
lemma Ideal.flat_of_inf_eq_mul (I : Ideal R) (H : ∀ ⦃J : Ideal R⦄, J.FG → I ⊓ J = I * J) :
    Module.Flat R (R ⧸ I) := by
  rw [Module.Flat.iff_lTensor_injective]
  intro J hJ
  rw [injective_lTensor_quotient_iff_inf_eq_mul]
  exact H hJ

@[stacks 04PS "(1) => (5)"]
lemma Ideal.exists_eq_mul_of_flat {I : Ideal R} [Module.Flat R (R ⧸ I)] {x : R} (hx : x ∈ I) :
    ∃ y ∈ I, x = x * y := by
  suffices h : x ∈ I * Ideal.span {x} by
    rw [Ideal.mem_mul_span_singleton] at h
    grind
  rw [← I.inf_eq_mul_of_flat]
  exact ⟨hx, subset_span rfl⟩

@[stacks 04PS "(5) => (7)"]
lemma Ideal.le_ker_atPrime_of_forall_exists_eq_mul {I : Ideal R}
    (h : ∀ x ∈ I, ∃ y ∈ I, x = x * y) {p : Ideal R} [p.IsPrime] (hle : I ≤ p) :
    I ≤ RingHom.ker (algebraMap R <| Localization.AtPrime p) := by
  intro x hx
  obtain ⟨y, hy, heq⟩ := h _ hx
  have : IsUnit (algebraMap R (Localization.AtPrime p) (1 - y)) := by
    rw [IsLocalization.algebraMap_isUnit_iff p.primeCompl]
    refine ⟨1 - y, fun hz ↦ p.one_notMem ?_, by simp⟩
    rw [← sub_add_cancel 1 y]
    exact Ideal.add_mem _ hz (hle hy)
  have hzero : x * (1 - y) = 0 := by simp [mul_sub, ← heq]
  simp only [RingHom.mem_ker, ← this.mul_left_eq_zero, ← RingHom.map_mul, hzero, RingHom.map_zero]

open PrimeSpectrum

lemma Ideal.map_atPrime_eq_top_of_not_le {I : Ideal R} {p : Ideal R} [p.IsPrime] (hle : ¬ I ≤ p) :
    Ideal.map (algebraMap R (Localization.AtPrime p)) I = ⊤ := by
  simp only [SetLike.le_def, not_forall] at hle
  obtain ⟨y, hy, hny⟩ := hle
  apply Ideal.eq_top_of_isUnit_mem
  · exact Ideal.mem_map_of_mem (algebraMap R _) hy
  · exact IsLocalization.map_units _ (⟨y, hny⟩ : p.primeCompl)

lemma Ideal.ker_piRingHom_atPrime_le (I : Ideal R) :
    RingHom.ker
      (Pi.ringHom fun p : zeroLocus (I : Set R) ↦
        algebraMap R (Localization.AtPrime p.val.asIdeal)) ≤ I := by
  intro x hx
  rw [RingHom.mem_ker, funext_iff] at hx
  refine Ideal.mem_of_localization_maximal fun m hm ↦ ?_
  by_cases hle : I ≤ m
  · convert Ideal.zero_mem _
    exact hx ⟨⟨m, hm.isPrime⟩, hle⟩
  · simp [Ideal.map_atPrime_eq_top_of_not_le hle]

lemma Ideal.ker_piRingHom_atPrime_eq_of_flat (I : Ideal R) [Module.Flat R (R ⧸ I)] :
    RingHom.ker
      (Pi.ringHom fun p : zeroLocus (I : Set R) ↦
        algebraMap R (Localization.AtPrime p.val.asIdeal)) = I := by
  refine le_antisymm (Ideal.ker_piRingHom_atPrime_le _) fun x hx ↦ ?_
  rw [RingHom.mem_ker]
  ext p
  rw [Pi.ringHom_apply, Pi.zero_apply]
  exact Ideal.le_ker_atPrime_of_forall_exists_eq_mul
    (fun x hx ↦ Ideal.exists_eq_mul_of_flat hx) p.2 hx

@[stacks 04PT]
lemma Ideal.zeroLocus_inj_of_flat {I J : Ideal R} [Module.Flat R (R ⧸ I)] [Module.Flat R (R ⧸ J)] :
    zeroLocus (I : Set R) = zeroLocus J ↔ I = J := by
  refine ⟨fun h ↦ ?_, fun h ↦ h ▸ rfl⟩
  rw [← I.ker_piRingHom_atPrime_eq_of_flat, ← J.ker_piRingHom_atPrime_eq_of_flat]
  generalize hs : zeroLocus (I : Set R) = s
  generalize ht : zeroLocus (J : Set R) = t
  obtain rfl : s = t := by rw [← hs, ← ht, h]
  rfl
