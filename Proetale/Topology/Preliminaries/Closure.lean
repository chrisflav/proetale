/-
Copyright (c) 2025 Jiedong Jiang, Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jiedong Jiang, Christian Merten
-/
import Mathlib.CategoryTheory.Limits.IsLimit
import Mathlib.Topology.Bases
import Mathlib.Topology.Category.TopCat.Basic
import Mathlib.CategoryTheory.Filtered.Basic
import Mathlib.Topology.Category.TopCat.Limits.Cofiltered

/-!
# Closures in categorical limits of topological spaces.

-/

open CategoryTheory Limits

universe u v w

-- generated by codex
theorem TopCat.closure_eq_iInter_preimage_closure_image {I : Type v} [Category.{w} I]
    [IsCofiltered I]
    {F : Functor I TopCat.{max v u}} {C : Cone F} (hC : IsLimit C) (s : Set C.pt) :
    closure s = ⋂ (i : I), (C.π.app i)⁻¹' (closure ((C.π.app i)'' s)) := by
  classical
  apply Set.Subset.antisymm
  · refine (Set.subset_iInter_iff).2 ?_
    intro i
    simpa using
      (closure_subset_preimage_closure_image (f := (C.π.app i)) (s := s)
        (C.π.app i).hom.continuous)
  · intro x hx
    -- Use a neighborhood basis of the limit topology consisting of preimages of open sets
    -- along the projections (available for cofiltered limits).
    have hB :
        TopologicalSpace.IsTopologicalBasis
          {U : Set C.pt |
            ∃ (j : I) (V : Set (F.obj j)), IsOpen V ∧ U = (C.π.app j) ⁻¹' V} := by
      simpa using
        (@TopCat.isTopologicalBasis_cofiltered_limit.{u, v, w} I (by infer_instance) (by infer_instance) F C hC
          (T := fun j => {V : Set (F.obj j) | IsOpen V})
          (hT := fun _ => TopologicalSpace.isTopologicalBasis_opens)
          (univ := fun _ => by simp)
          (inter := fun _ U1 U2 h1 h2 => by simpa using h1.inter h2)
          (compat := fun _ _ f V hV => by simpa using hV.preimage (F.map f).hom.continuous))
    -- Membership in the closure is tested against all basis opens containing the point.
    refine (hB.mem_closure_iff (s := s) (a := x)).2 ?_
    intro o ho hxo
    rcases ho with ⟨j, V, hVopen, rfl⟩
    have hxj : (C.π.app j) x ∈ closure ((C.π.app j) '' s) := by
      simpa [Set.mem_preimage] using (Set.mem_iInter.mp hx j)
    have hxV : (C.π.app j) x ∈ V := by
      simpa [Set.mem_preimage] using hxo
    -- Since `(C.π.app j) x ∈ closure ((C.π.app j) '' s)`, every open neighborhood meets the image.
    rcases (mem_closure_iff.1 hxj) V hVopen hxV with ⟨z, hz⟩
    rcases hz with ⟨hzV, hzIm⟩
    rcases hzIm with ⟨y, hyS, rfl⟩
    exact ⟨y, ⟨hzV, hyS⟩⟩

theorem image_closure_image_subset_closure_image {I : Type*} [Category I]
    {F : Functor I TopCat} (C : Cone F) (s : Set C.pt) {i j : I} (f : i ⟶ j) :
    (F.map f) '' (closure ((C.π.app i) '' s)) ⊆ closure ((C.π.app j) '' s) := by
  have hf : Continuous (F.map f) := (F.map f).hom.continuous
  have himage : (F.map f) '' ((C.π.app i) '' s) = (C.π.app j) '' s := by
    -- Rewrite as the image under a composite map, then use the cone commutativity `C.w f`.
    have hcomp :
        (fun x => (F.map f) ((C.π.app i) x)) '' s = (fun x => (C.π.app j) x) '' s := by
      refine Set.image_congr ?_
      intro x hx
      -- Evaluate `C.w f : C.π.app i ≫ F.map f = C.π.app j` at `x`.
      change
          (ConcreteCategory.hom (C.π.app i ≫ F.map f)) x =
            (ConcreteCategory.hom (C.π.app j)) x
      exact congrArg (fun g : C.pt ⟶ F.obj j => (ConcreteCategory.hom g) x) (C.w f)
    simpa [Set.image_image, Function.comp] using hcomp
  -- Apply continuity of `F.map f` to move closure through the image, then rewrite the image.
  simpa [himage] using
    (image_closure_subset_closure_image (f := (F.map f)) (s := (C.π.app i) '' s) hf)
  -- image_closure_subset_closure_image
