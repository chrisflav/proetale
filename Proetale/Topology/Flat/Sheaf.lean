/-
Copyright (c) 2025 Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christian Merten
-/
import Proetale.Topology.Flat.QuasiCompactCover
import Proetale.Mathlib.AlgebraicGeometry.Sites.BigZariski
import Proetale.Mathlib.AlgebraicGeometry.Limits
import Proetale.Mathlib.AlgebraicGeometry.Sites.MorphismProperty
import Proetale.Mathlib.AlgebraicGeometry.Extensive
import Mathlib.AlgebraicGeometry.Morphisms.Flat
import Mathlib.AlgebraicGeometry.Sites.MorphismProperty
import Mathlib.CategoryTheory.EffectiveEpi.Basic
import Mathlib.CategoryTheory.Sites.EffectiveEpimorphic
import Mathlib.CategoryTheory.Sites.Canonical
import Mathlib.CategoryTheory.Sites.Preserves
import Mathlib.AlgebraicGeometry.Sites.BigZariski
import Mathlib.CategoryTheory.Limits.Shapes.DisjointCoproduct

/-!
# The fpqc topology is subcanonical

In this file we show that the fqpc topology of a scheme is subcanonical. This implies that
all coarser topologies, e.g., the (pro)√©tale topology, are subcanonical.
-/

universe v u

open CategoryTheory Limits Opposite

namespace CategoryTheory

instance {C : Type*} [Category C] : (‚ä§ : MorphismProperty C).IsStableUnderBaseChange where
  of_isPullback _ _ := trivial

variable {C : Type*} [Category C] {X : C}

def CoproductDisjoint.of_binaryCofan_of_pullbackCone {X Y : C}
    (c : BinaryCofan X Y) (hc : IsColimit c)
    (d : PullbackCone c.inl c.inr) (hd : IsLimit d)
    (H : IsInitial d.pt) [Mono c.inl] [Mono c.inr] :
    CoproductDisjoint X Y where
  isInitialOfIsPullbackOfIsCoproduct {A B} p q f g h hsq hl := by
    let e := h.uniqueUpToIso hc
    have hp : p ‚â´ e.hom.hom = c.inl := e.hom.w ‚ü®.left‚ü©
    have hq : q ‚â´ e.hom.hom = c.inr := e.hom.w ‚ü®.right‚ü©
    let u : B ‚ü∂ d.pt := by
      refine PullbackCone.IsLimit.lift hd f g ?_
      ¬∑ rw [‚Üê hp, reassoc_of% hsq, reassoc_of% show q = c.inr ‚â´ e.inv.hom by simp]
        rw [CoconeMorphism.w_assoc, CoconeMorphism.w]
    have hu1 : u ‚â´ d.fst = f := by simp [u]
    have hu2 : u ‚â´ d.snd = g := by simp [u]
    refine H.ofIso ‚ü®H.to B, u, H.hom_ext _ _, PullbackCone.IsLimit.hom_ext hl ?_ ?_‚ü©
    ¬∑ simp [‚Üê hu1, show H.to X = d.fst from H.hom_ext _ _]
    ¬∑ simp [‚Üê hu2, show H.to Y = d.snd from H.hom_ext _ _]
  mono_inl B p q h := by
    rw [show p = c.inl ‚â´ (h.uniqueUpToIso hc).inv.hom by simp]
    infer_instance
  mono_inr B p q h := by
    rw [show q = c.inr ‚â´ (h.uniqueUpToIso hc).inv.hom by simp]
    infer_instance

lemma Limits.preservesFiniteProducts_of_preservesLimitsOfShape {D : Type*} [Category D] (F : C ‚•§ D)
    (H : ‚àÄ (Œπ : Type v) [Finite Œπ], PreservesLimitsOfShape (Discrete Œπ) F) :
    PreservesFiniteProducts F := by
  constructor
  intro n
  exact preservesLimitsOfShape_of_equiv (Discrete.equivalence Equiv.ulift) F

lemma Sieve.EffectiveEpimorphic.iff_forall_isSheafFor_yoneda (S : Sieve X) :
    S.EffectiveEpimorphic ‚Üî ‚àÄ Y, S.arrows.IsSheafFor (yoneda.obj Y) :=
  S.forallYonedaIsSheaf_iff_colimit.symm

lemma Presieve.EffectiveEpimorphic.iff_forall_isSheafFor_yoneda (S : Presieve X) :
    S.EffectiveEpimorphic ‚Üî ‚àÄ Y, S.IsSheafFor (yoneda.obj Y) := by
  simp_rw [Presieve.isSheafFor_iff_generate S]
  rw [Presieve.EffectiveEpimorphic, Sieve.EffectiveEpimorphic.iff_forall_isSheafFor_yoneda]

-- TODO: this is almost in mathlib, with slightly less general universe assumptions on `F`
-- and with a wrong name
lemma Presieve.IsSheafFor.of_isSheafFor_pullback'' (F : C·µí·µñ ‚•§ Type*) {X : C}
    (S T : Sieve X)
    (hF : Presieve.IsSheafFor F S.arrows)
    (hF' : ‚àÄ {Y : C} (f : Y ‚ü∂ X), Presieve.IsSeparatedFor F (S.pullback f).arrows)
    (H : ‚àÄ {Y : C} (f : Y ‚ü∂ X), S f ‚Üí Presieve.IsSheafFor F (T.pullback f).arrows) :
    Presieve.IsSheafFor F T.arrows := by
  intro t ht
  have ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X) (hf : S f) := H f hf (t.pullback f) (ht.pullback f)
  choose s hs huniq using this
  have hr : FamilyOfElements.Compatible s := by
    rw [Presieve.compatible_iff_sieveCompatible]
    intro Y Z f g hf
    refine (H (g ‚â´ f) (by simp [hf])).isSeparatedFor.ext fun U o ho ‚Ü¶ ?_
    simp only [Sieve.pullback_apply] at ho
    dsimp only [FamilyOfElements.IsAmalgamation, FamilyOfElements.pullback] at hs
    rw [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, hs _ _ _ ho, hs _ _ _ (by simpa)]
    congr 1
    simp
  obtain ‚ü®t', ht', hunique‚ü© := hF s hr
  refine ‚ü®t', fun Y f hf ‚Ü¶ (hF' f).ext fun Z g hg ‚Ü¶ ?_, fun y hy ‚Ü¶ ?_‚ü©
  ¬∑ rw [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, ht' (g ‚â´ f) hg, ‚Üê t.comp_of_compatible _ ht]
    have := hs (g ‚â´ f) hg (ùüô _)
    dsimp only [Presieve.FamilyOfElements.IsAmalgamation,
      Presieve.FamilyOfElements.pullback] at this
    simp only [Sieve.pullback_apply, Category.id_comp, op_id, FunctorToTypes.map_id_apply] at this
    rw [this]
    ¬∑ congr 1
      simp
    ¬∑ simp [hf]
  ¬∑ refine hunique _ fun Y f hf ‚Ü¶ huniq _ _ _ fun Z g hg ‚Ü¶ ?_
    simp [Presieve.FamilyOfElements.pullback, ‚Üê hy _ hg]

lemma Presieve.IsSheafFor.of_isSheafFor_pullback
    (F : C·µí·µñ ‚•§ Type*) {X : C}
    (S : Presieve X) (T : Sieve X) [S.hasPullbacks]
    (hF : Presieve.IsSheafFor F S)
    (hF' : ‚àÄ {Y : C} (f : Y ‚ü∂ X), Presieve.IsSeparatedFor F ((Sieve.generate S).pullback f).arrows)
    (H' : ‚àÄ {Y Z : C} (f : Y ‚ü∂ X) (g : Z ‚ü∂ X) (hf : S f) (hg : S g),
      haveI := hasPullbacks.has_pullbacks hf hg
      ‚àÉ (R : Presieve (pullback f g)), Presieve.IsSeparatedFor F R ‚àß
        ‚àÄ {W : C} (w : W ‚ü∂ pullback f g),
          R w ‚Üí Presieve.IsSeparatedFor F (T.pullback (w ‚â´ pullback.fst f g ‚â´ f)).arrows)
    (H : ‚àÄ {Y : C} (f : Y ‚ü∂ X), S f ‚Üí Presieve.IsSheafFor F (T.pullback f).arrows) :
    Presieve.IsSheafFor F T.arrows := by
  intro t ht
  have ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X) (hf : S f) := H f hf (t.pullback f) (ht.pullback f)
  choose s hs huniq using this
  have hr : FamilyOfElements.Compatible s := by
    rw [pullbackCompatible_iff]
    intro Y Z f g hf hg
    haveI := hasPullbacks.has_pullbacks hf hg
    obtain ‚ü®R, hR, h‚ü© := H' f g hf hg
    refine hR.ext fun W w hw ‚Ü¶ (h w hw).ext fun U u hu ‚Ü¶ ?_
    simp only [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, Category.assoc]
    dsimp only [FamilyOfElements.IsAmalgamation, FamilyOfElements.pullback] at hs
    rw [hs f hf (u ‚â´ w ‚â´ pullback.fst f g) (by simpa),
      hs g hg (u ‚â´ w ‚â´ pullback.snd f g) (by simpa [‚Üê pullback.condition])]
    congr 1
    simp [pullback.condition]
  obtain ‚ü®t', ht', hunique‚ü© := hF s hr
  refine ‚ü®t', fun Y f hf ‚Ü¶ (hF' f).ext fun Z g hg ‚Ü¶ ?_, fun y hy ‚Ü¶ ?_‚ü©
  ¬∑ rw [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp]
    simp only [Sieve.pullback_apply, Sieve.generate_apply] at hg
    obtain ‚ü®W, w, u, hu, heq‚ü© := hg
    simp only [‚Üê heq, op_comp, FunctorToTypes.map_comp_apply, ht' u hu]
    have : t (g ‚â´ f) (by simp [hf]) = t (w ‚â´ u) (by simp [heq, hf]) := by
      congr 1
      rw [heq]
    rw [‚Üê t.comp_of_compatible _ ht, this]
    apply hs
  ¬∑ refine hunique _ fun Y f hf ‚Ü¶ huniq _ _ _ fun Z g hg ‚Ü¶ ?_
    simp [Presieve.FamilyOfElements.pullback, ‚Üê hy _ hg]

lemma Presieve.IsSheafFor.of_isSheafFor_pullback' (F : C·µí·µñ ‚•§ Type*) {X : C}
    (S T : Presieve X) [S.hasPullbacks]
    (hF : Presieve.IsSheafFor F S)
    (hF' : ‚àÄ {Y : C} (f : Y ‚ü∂ X), Presieve.IsSeparatedFor F ((Sieve.generate S).pullback f).arrows)
    (H' : ‚àÄ {Y Z : C} (f : Y ‚ü∂ X) (g : Z ‚ü∂ X) (hf : S f) (hg : S g),
      haveI := hasPullbacks.has_pullbacks hf hg
      ‚àÉ (R : Presieve (pullback f g)), Presieve.IsSeparatedFor F R ‚àß
        ‚àÄ {W : C} (w : W ‚ü∂ pullback f g),
          R w ‚Üí Presieve.IsSeparatedFor F ((Sieve.generate T).pullback (w ‚â´ pullback.fst f g ‚â´ f)).arrows)
    (H : ‚àÄ {Y : C} (f : Y ‚ü∂ X), S f ‚Üí Presieve.IsSheafFor F ((Sieve.generate T).pullback f).arrows) :
    Presieve.IsSheafFor F T := by
  rw [isSheafFor_iff_generate]
  apply Presieve.IsSheafFor.of_isSheafFor_pullback F S _ _ hF'
  ¬∑ assumption
  ¬∑ assumption
  ¬∑ assumption

-- this needs more assumptions, but the proof will show which the correct ones are
lemma Presieve.isSheafFor_ofArrows_comp {F : C·µí·µñ ‚•§ Type*} {Œπ : Type*} {Y Z : Œπ ‚Üí C}
    (f : ‚àÄ i, Y i ‚ü∂ X) (g : ‚àÄ i, Z i ‚ü∂ X)
    (e : ‚àÄ i, Y i ‚âÖ Z i) (H : Presieve.IsSheafFor F (.ofArrows _ g)) :
    Presieve.IsSheafFor F (.ofArrows _ (fun i ‚Ü¶ (e i).hom ‚â´ g i)) := by
  let B (W : C) (w : W ‚ü∂ X) (hw : Presieve.ofArrows _ g w) : Sieve W :=
    sorry
  have : .ofArrows _ (fun i ‚Ü¶ (e i).hom ‚â´ g i) = Sieve.bind (.ofArrows _ g) B :=
    sorry
  rw [Presieve.isSheafFor_iff_generate, ‚Üê Sieve.ofArrows, this]
  sorry

/--
If

- `F` contravariantly maps (suitable) coproducts to products,
- (suitable) coproducts exist in `C`, and
- (suitable) coproducts distribute over pullbacks, then:

`F` is a sheaf for the single object covering `{ ‚àê·µ¢ Y·µ¢ ‚ü∂ X }`
if and only if it is a presieve for `{ f·µ¢ : Y·µ¢ ‚ü∂ X }·µ¢`.
-/
lemma Presieve.isSheafFor_sigmaDesc_iff {F : C·µí·µñ ‚•§ Type*} {X : C} {Œπ : Type} {Y : Œπ ‚Üí C}
    (f : ‚àÄ i, Y i ‚ü∂ X) [(ofArrows Y f).hasPullbacks]
    [HasCoproduct Y] [HasCoproduct fun (ij : Œπ √ó Œπ) ‚Ü¶ pullback (f ij.1) (f ij.2)]
    [HasPullback (Limits.Sigma.desc f) (Limits.Sigma.desc f)]
    [PreservesLimit (Discrete.functor <| fun i ‚Ü¶ op (Y i)) F]
    [PreservesLimit (Discrete.functor fun (ij : Œπ √ó Œπ) ‚Ü¶ op (pullback (f ij.1) (f ij.2))) F]
    [IsIso (Limits.Sigma.desc fun (ij : Œπ √ó Œπ) ‚Ü¶ Limits.pullback.map (f ij.fst) (f ij.snd)
      (Limits.Sigma.desc f) (Limits.Sigma.desc f) (Limits.Sigma.Œπ _ _) (Limits.Sigma.Œπ _ _) (ùüô X)
      (by simp) (by simp))] :
    Presieve.IsSheafFor F (.singleton <| Limits.Sigma.desc f) ‚Üî
      Presieve.IsSheafFor F (.ofArrows Y f) := by
  let e : (‚àê fun (ij : Œπ √ó Œπ) ‚Ü¶ pullback (f ij.1) (f ij.2)) ‚ü∂
      pullback (Limits.Sigma.desc f) (Limits.Sigma.desc f) :=
    Limits.Sigma.desc fun ij ‚Ü¶
    pullback.map _ _ _ _ (Limits.Sigma.Œπ _ _) (Limits.Sigma.Œπ _ _) (ùüô X) (by simp) (by simp)
  rw [Equalizer.Presieve.isSheafFor_singleton_iff (pullback.cone _ _) (pullback.isLimit _ _),
    Equalizer.Presieve.Arrows.sheaf_condition]
  refine (Fork.isLimitEquivOfIsos _ _ ?_ ?_ ?_ ?_ ?_ ?_).nonempty_congr
  ¬∑ exact F.mapIso (opCoproductIsoProduct Y) ‚â™‚â´ PreservesProduct.iso F _
  ¬∑ exact F.mapIso (.op <| asIso e) ‚â™‚â´ F.mapIso (opCoproductIsoProduct _) ‚â™‚â´
      PreservesProduct.iso F _
  ¬∑ exact Iso.refl _
  ¬∑ refine Pi.hom_ext _ _ fun ij ‚Ü¶ ?_
    simp only [Iso.trans_hom, Functor.mapIso_hom, PreservesProduct.iso_hom, Category.assoc,
      limit.cone_x, PullbackCone.fst_limit_cone, Iso.op_hom, asIso_hom, e, piComparison_comp_œÄ,
      Equalizer.Presieve.Arrows.firstMap]
    rw [‚Üê F.map_comp, opCoproductIsoProduct_hom_comp_œÄ, ‚Üê F.map_comp, ‚Üê op_comp, Sigma.Œπ_desc,
      ‚Üê F.map_comp, ‚Üê op_comp, pullback.lift_fst, Pi.lift_œÄ, piComparison_comp_œÄ_assoc,
      ‚Üê F.map_comp, ‚Üê F.map_comp]
    simp
  ¬∑ refine Pi.hom_ext _ _ fun ij ‚Ü¶ ?_
    simp only [Iso.trans_hom, Functor.mapIso_hom, PreservesProduct.iso_hom, Category.assoc,
      limit.cone_x, PullbackCone.snd_limit_cone, Iso.op_hom, asIso_hom, e, piComparison_comp_œÄ,
      Equalizer.Presieve.Arrows.secondMap]
    rw [‚Üê F.map_comp, opCoproductIsoProduct_hom_comp_œÄ, ‚Üê F.map_comp, ‚Üê op_comp, Sigma.Œπ_desc,
      ‚Üê F.map_comp, ‚Üê op_comp, pullback.lift_snd, Pi.lift_œÄ, piComparison_comp_œÄ_assoc,
      ‚Üê F.map_comp, ‚Üê F.map_comp]
    simp
  ¬∑ refine Pi.hom_ext _ _ fun i ‚Ü¶ ?_
    simp only [Fork.ofŒπ_pt, Fork.Œπ_ofŒπ, Iso.trans_hom, Functor.mapIso_hom, PreservesProduct.iso_hom,
      Category.assoc, piComparison_comp_œÄ]
    rw [‚Üê F.map_comp, ‚Üê F.map_comp, opCoproductIsoProduct_hom_comp_œÄ, ‚Üê op_comp, Sigma.Œπ_desc]
    simp [Equalizer.Presieve.Arrows.forkMap]

end CategoryTheory

namespace AlgebraicGeometry

variable {P : MorphismProperty Scheme.{u}}

open Scheme

def qcPretopology (P : MorphismProperty Scheme.{u}) [P.IsMultiplicative]
    [P.IsStableUnderBaseChange] : Pretopology Scheme.{u} where
  coverings Y S := ‚àÉ (ùí∞ : Cover.{u} P Y) (h : ùí∞.QuasiCompact), S = Presieve.ofArrows ùí∞.obj ùí∞.map
  has_isos _ _ f _ := ‚ü®coverOfIsIso f, inferInstance, (Presieve.ofArrows_pUnit _).symm‚ü©
  pullbacks := by
    rintro Y X f _ ‚ü®ùí∞, hùí∞, rfl‚ü©
    exact ‚ü®ùí∞.pullbackCover' f, inferInstance, (Presieve.ofArrows_pullback _ _ _).symm‚ü©
  transitive := by
    rintro X _ T ‚ü®ùí∞, hùí∞, rfl‚ü© H
    choose ùí± hcùí± hùí± using H
    refine ‚ü®ùí∞.bind (fun j ‚Ü¶ ùí± (ùí∞.map j) ‚ü®j‚ü©), inferInstance, ?_‚ü©
    simpa only [Cover.bind, ‚Üê hùí±] using Presieve.ofArrows_bind ùí∞.obj ùí∞.map _
      (fun _ f H => (ùí± f H).obj) (fun _ f H => (ùí± f H).map)

abbrev fpqcPretopology : Pretopology Scheme.{u} := qcPretopology @Flat

abbrev qcTopology (P : MorphismProperty Scheme.{u}) [P.IsMultiplicative]
    [P.IsStableUnderBaseChange] : GrothendieckTopology Scheme.{u} := (qcPretopology P).toGrothendieck

@[simp]
lemma Scheme.Cover.generate_ofArrows_mem_qcTopology [P.IsMultiplicative]
    [P.IsStableUnderBaseChange] {S : Scheme.{u}} (ùí∞ : Cover.{u} P S) [ùí∞.QuasiCompact] :
    .generate (.ofArrows ùí∞.obj ùí∞.map) ‚àà qcTopology P S := by
  rw [qcTopology, Pretopology.mem_toGrothendieck]
  exact ‚ü®.ofArrows ùí∞.obj ùí∞.map, ‚ü®ùí∞, ‚Äπ_‚Ä∫, rfl‚ü©, Sieve.le_generate _‚ü©

variable (P : MorphismProperty Scheme.{u}) [P.IsMultiplicative] [P.IsStableUnderBaseChange]

/-- The fqpc-topology on the category of schemes is the Grothendieck topology associated
to the pretopology given by fqpc-covers. -/
abbrev fpqcTopology : GrothendieckTopology Scheme.{u} := fpqcPretopology.toGrothendieck

lemma zariskiTopology_le_qcTopology [IsLocalAtSource P] :
    zariskiTopology ‚â§ qcTopology P := by
  rw [qcTopology, zariskiTopology, (Pretopology.gi _).gc.le_iff_le]
  rintro S R ‚ü®ùí∞, rfl‚ü©
  rw [Pretopology.mem_ofGrothendieck]
  let ùí∞' : Cover P S := ùí∞.changeProp P (fun j ‚Ü¶ IsLocalAtSource.of_isOpenImmersion _)
  have : ùí∞'.QuasiCompact := ‚ü®(inferInstanceAs <| ùí∞.QuasiCompact).1‚ü©
  exact ùí∞'.generate_ofArrows_mem_qcTopology

variable {P} in
@[simps!]
noncomputable
def Scheme.Hom.cover {X S : Scheme.{u}} (f : X ‚ü∂ S) (hf : P f) [Surjective f] : Cover.{v} P S :=
  .mkOfCovers PUnit.{v + 1} (fun _ ‚Ü¶ X) (fun _ ‚Ü¶ f) (fun x ‚Ü¶ ‚ü®‚ü®‚ü©, f.surjective x‚ü©) (fun _ ‚Ü¶ hf)

instance {X S : Scheme.{u}} (f : X ‚ü∂ S) (hf : P f) [Surjective f] [QuasiCompact f] :
    (f.cover hf).QuasiCompact :=
  sorry

lemma ofArrows_homCover {X S : Scheme.{u}} (f : X ‚ü∂ S) (hf : P f) [Surjective f] :
    Presieve.ofArrows (f.cover hf).obj (f.cover hf).map = Presieve.singleton f :=
  sorry

open Opposite

@[simps!]
noncomputable
def Scheme.affineCover' (X : Scheme.{u}) : X.OpenCover :=
  .mkOfCovers X.affineOpens (fun i ‚Ü¶ i.1) (fun i ‚Ü¶ i.1.Œπ) fun x ‚Ü¶ by
    obtain ‚ü®U, hU, hx, -‚ü© := TopologicalSpace.Opens.isBasis_iff_nbhd.mp (isBasis_affine_open X)
      (show x ‚àà ‚ä§ from trivial)
    exact ‚ü®‚ü®U, hU‚ü©, ‚ü®x, hx‚ü©, rfl‚ü©

variable {P}

lemma Cover.QuasiCompact.exists_hom {S : Scheme.{u}} (ùí∞ : S.Cover P)
    [CompactSpace S] [ùí∞.QuasiCompact] :
    ‚àÉ (ùí± : S.AffineCover P) (f : ùí±.cover ‚ü∂ ùí∞), Finite ùí±.J ‚àß ‚àÄ j, IsOpenImmersion (f.app j) :=
  sorry

lemma Scheme.Cover.Hom.isSheafFor {F : Scheme.{u}·µí·µñ ‚•§ Type*} {S : Scheme.{u}} {ùí∞ ùí± : S.Cover P}
    (f : ùí∞ ‚ü∂ ùí±)
    (H‚ÇÅ : Presieve.IsSheafFor F (.ofArrows _ ùí∞.map))
    (H‚ÇÇ : ‚àÄ {X : Scheme.{u}} (f : X ‚ü∂ S),
      Presieve.IsSeparatedFor F (.ofArrows (ùí∞.pullbackCover' f).obj (ùí∞.pullbackCover' f).map)) :
    Presieve.IsSheafFor F (.ofArrows ùí±.obj ùí±.map) := by
  rw [Presieve.isSheafFor_iff_generate]
  apply Presieve.isSheafFor_subsieve_aux (S := .generate (.ofArrows ùí∞.obj ùí∞.map))
  ¬∑ show Sieve.generate _ ‚â§ Sieve.generate _
    rw [Sieve.generate_le_iff]
    rintro - - ‚ü®i‚ü©
    rw [‚Üê f.w]
    exact ‚ü®_, f.app i, ùí±.map _, ‚ü®_‚ü©, rfl‚ü©
  ¬∑ rwa [‚Üê Presieve.isSheafFor_iff_generate]
  ¬∑ intro Y f hf
    rw [‚Üê Sieve.pullbackArrows_comm, ‚Üê Presieve.isSeparatedFor_iff_generate]
    rw [‚Üê Presieve.ofArrows_pullback]
    apply H‚ÇÇ

lemma bot_mem_grothendieckTopology (X : Scheme.{u}) [IsEmpty X] :
    ‚ä• ‚àà Scheme.grothendieckTopology P X := by
  rw [‚Üê Sieve.generate_bot]
  let ùí∞ : Cover.{u} P X :=
    { J := PEmpty
      obj := PEmpty.elim
      map i := i.elim
      f x := (IsEmpty.false x).elim
      covers x := (IsEmpty.false x).elim
      map_prop x := x.elim }
  have : Presieve.ofArrows ùí∞.obj ùí∞.map = ‚ä• := by
    rw [eq_bot_iff]
    rintro - - ‚ü®i‚ü©
    exact i.elim
  rw [‚Üê this]
  exact ùí∞.generate_ofArrows_mem_grothendieckTopology

-- universe restrictions can be removed again, after #25764 is merged
lemma preservesFiniteProducts_of_isSheaf_zariskiTopology {F : Scheme.{0}·µí·µñ ‚•§ Type*}
    (hF : Presieve.IsSheaf Scheme.zariskiTopology F) :
    PreservesFiniteProducts F := by
  apply Limits.preservesFiniteProducts_of_preservesLimitsOfShape.{0}
  intro Œπ _
  apply (config := { allowSynthFailures := true }) preservesLimitsOfShape_of_discrete
  intro X
  let X' := unop ‚àò X
  show PreservesLimit (Discrete.functor fun i ‚Ü¶ op (X' i)) F
  have (i : Œπ) : Mono (Cofan.inj (Sigma.cocone (Discrete.functor X')) i) :=
    inferInstanceAs <| Mono (Sigma.Œπ _ _)
  refine Presieve.preservesProduct_of_isSheafFor F ?_ initialIsInitial
      (Sigma.cocone (Discrete.functor X')) (coproductIsCoproduct' _) ?_ ?_
  ¬∑ apply hF.isSheafFor
    convert bot_mem_grothendieckTopology (‚ä•_ Scheme)
    rw [eq_bot_iff]
    rintro Y f ‚ü®g, _, _, ‚ü®i‚ü©, _‚ü©
    exact i.elim
  ¬∑ intro i j hij
    refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
    ¬∑ simp
    ¬∑ refine PullbackCone.IsLimit.mk ?_ ?_ ?_ ?_ ?_
      ¬∑ intro s
        have : IsEmpty s.pt := isEmpty_of_commSq_sigmaŒπ_of_ne ‚ü®s.condition‚ü© hij
        exact isInitialOfIsEmpty.to _
      ¬∑ intro s
        have : IsEmpty s.pt := isEmpty_of_commSq_sigmaŒπ_of_ne ‚ü®s.condition‚ü© hij
        apply isInitialOfIsEmpty.hom_ext
      ¬∑ intro s
        have : IsEmpty s.pt := isEmpty_of_commSq_sigmaŒπ_of_ne ‚ü®s.condition‚ü© hij
        apply isInitialOfIsEmpty.hom_ext
      ¬∑ intro s m
        have : IsEmpty s.pt := isEmpty_of_commSq_sigmaŒπ_of_ne ‚ü®s.condition‚ü© hij
        intro x y
        apply isInitialOfIsEmpty.hom_ext
  ¬∑ exact hF.isSheafFor _ _ (sigmaOpenCover' X').generate_ofArrows_mem_grothendieckTopology

lemma Scheme.Cover.isSheafFor_sigma_iff' {F : Scheme.{u}·µí·µñ ‚•§ Type (max u (u + 1))} [IsLocalAtSource P]
    (hF : Presieve.IsSheaf Scheme.zariskiTopology F)
    {S : Scheme.{u}} (ùí∞ : S.Cover P) :
    Presieve.IsSheafFor F (.ofArrows ùí∞.sigma.obj ùí∞.sigma.map) ‚Üî
      Presieve.IsSheafFor F (.ofArrows ùí∞.obj ùí∞.map) := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ rw [Equalizer.Presieve.sheaf_condition]
    sorry
  ¬∑ sorry

lemma Scheme.Cover.isSheafFor_sigma_iff {F : Scheme.{u}·µí·µñ ‚•§ Type*} [IsLocalAtSource P]
    (hF : Presieve.IsSheaf Scheme.zariskiTopology F)
    {S : Scheme.{u}} (ùí∞ : S.Cover P) :
    Presieve.IsSheafFor F (.ofArrows ùí∞.sigma.obj ùí∞.sigma.map) ‚Üî
      Presieve.IsSheafFor F (.ofArrows ùí∞.obj ùí∞.map) := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ intro x hx
    let ùí± : OpenCover (‚àê ùí∞.obj) := sigmaOpenCover' _
    let P : Presieve (‚àê ùí∞.obj) := Presieve.ofArrows _ ùí±.map
    let fam : P.FamilyOfElements F := sorry
    let z : F.obj (op <| ‚àê ùí∞.obj) :=
      (hF.isSheafFor _ _ (generate_ofArrows_mem_grothendieckTopology _ _)).amalgamate fam
        sorry
    let y : Presieve.FamilyOfElements F (Presieve.ofArrows ùí∞.sigma.obj ùí∞.sigma.map) :=
      sorry
    sorry
  ¬∑ sorry

lemma Scheme.Cover.ofArrows_of_unique {S : Scheme.{u}} (ùí∞ : S.Cover P) [Unique ùí∞.J] :
    Presieve.ofArrows ùí∞.obj ùí∞.map = Presieve.singleton (ùí∞.map default) :=
  sorry

instance {S : Scheme.{u}} [IsAffine S] (ùí∞ : S.AffineCover P) [Finite ùí∞.J] :
    ùí∞.cover.QuasiCompact :=
  sorry

lemma isSheafFor_iff_of_iso {F : Scheme.{u}·µí·µñ ‚•§ Type*} {S X Y : Scheme.{u}} (f : X ‚ü∂ S) (g : Y ‚ü∂ S)
    (e : X ‚âÖ Y) (hF : Presieve.IsSheaf Scheme.zariskiTopology F)
    (he : e.hom ‚â´ g = f) :
    Presieve.IsSheafFor F (.singleton f) ‚Üî Presieve.IsSheafFor F (.singleton g) := by
  subst he
  refine ‚ü®fun hf ‚Ü¶ ?_, ?_‚ü©
  ¬∑ sorry
  ¬∑ sorry

/-- A pre-sheaf is a sheaf for the `P`-qc topology if and only if it is a sheaf
for the Zariski topology and satisfies the sheaf property for all single object coverings
`{ f : Spec S ‚ü∂ Spec R }` where `f` satisifies `P`.-/
@[stacks 022H]
nonrec lemma isSheaf_qcTopology_iff (F : Scheme.{u}·µí·µñ ‚•§ Type*) [IsLocalAtSource P] :
    Presieve.IsSheaf (qcTopology P) F ‚Üî
      Presieve.IsSheaf Scheme.zariskiTopology F ‚àß
        ‚àÄ {R S : CommRingCat.{u}} (f : R ‚ü∂ S), P (Spec.map f) ‚Üí Surjective (Spec.map f) ‚Üí
          Presieve.IsSheafFor F (.singleton (Spec.map f)) := by
  refine ‚ü®fun hF ‚Ü¶ ‚ü®?_, fun {R S} f hf hs ‚Ü¶ ?_‚ü©, fun ‚ü®hzar, hff‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ exact Presieve.isSheaf_of_le _ (zariskiTopology_le_qcTopology P) hF
  ¬∑ apply hF.isSheafFor
    rw [‚Üê ofArrows_homCover P _ hf]
    exact Cover.generate_ofArrows_mem_qcTopology _
  ¬∑ rw [Presieve.isSheaf_pretopology]
    rintro T - ‚ü®ùí∞, _, rfl‚ü©
    wlog hT : ‚àÉ (R : CommRingCat.{u}), T = Spec R generalizing T
    ¬∑ let ùí± : T.OpenCover := T.affineCover
      have h (j : T.affineCover.J) : Presieve.IsSheafFor F
          (.ofArrows (ùí∞.pullbackCover' (ùí±.map j)).obj (ùí∞.pullbackCover' (ùí±.map j)).map) :=
        this _ inferInstance ‚ü®_, rfl‚ü©
      refine .of_isSheafFor_pullback' F (.ofArrows ùí±.obj ùí±.map) _ ?_ ?_ ?_ ?_
      ¬∑ exact hzar.isSheafFor _ _ ùí±.generate_ofArrows_mem_grothendieckTopology
      ¬∑ intro Y f
        refine (hzar.isSheafFor _ _ ?_).isSeparatedFor
        rw [Sieve.generate_sieve, ‚Üê Sieve.pullbackArrows_comm, Cover.pullbackArrows_ofArrows]
        exact (Cover.pullbackCover' ùí± f).generate_ofArrows_mem_grothendieckTopology
      ¬∑ rintro - - - - ‚ü®i‚ü© ‚ü®j‚ü©
        use .ofArrows (pullback (ùí±.map i) (ùí±.map j)).affineCover.obj
          (pullback (ùí±.map i) (ùí±.map j)).affineCover.map
        refine ‚ü®(hzar.isSheafFor _ _ <|
            Cover.generate_ofArrows_mem_grothendieckTopology _ _).isSeparatedFor, ?_‚ü©
        ¬∑ rintro - - ‚ü®k‚ü©
          rw [‚Üê Sieve.pullbackArrows_comm, ‚Üê Presieve.isSeparatedFor_iff_generate]
          apply Presieve.IsSheafFor.isSeparatedFor
          rw [‚Üê Presieve.ofArrows_pullback]
          exact this (ùí∞.pullbackCover' _) inferInstance ‚ü®_, rfl‚ü©
      ¬∑ rintro - - ‚ü®i‚ü©
        rw [‚Üê Sieve.pullbackArrows_comm, ‚Üê Presieve.ofArrows_pullback,
          ‚Üê Presieve.isSheafFor_iff_generate]
        exact this (ùí∞.pullbackCover' (ùí±.map i)) inferInstance ‚ü®_, rfl‚ü©
    obtain ‚ü®R, rfl‚ü© := hT
    wlog hùí∞ : (‚àÄ i, IsAffine (ùí∞.obj i)) ‚àß Finite ùí∞.J generalizing R ùí∞
    ¬∑ obtain ‚ü®ùí±, f, hfin, ho‚ü© := Cover.QuasiCompact.exists_hom ùí∞
      have H (V : Scheme.{u}) (f : V ‚ü∂ Spec R) : Presieve.IsSheafFor F
          (.ofArrows (ùí±.cover.pullbackCover' f).obj (ùí±.cover.pullbackCover' f).map) := by
        let ùí∞V := V.affineCover
        refine .of_isSheafFor_pullback' F (.ofArrows ùí∞V.obj ùí∞V.map) _ ?_ ?_ ?_ ?_
        ¬∑ exact hzar.isSheafFor _ _ ùí∞V.generate_ofArrows_mem_grothendieckTopology
        ¬∑ intro Y f
          refine (hzar.isSheafFor _ _ ?_).isSeparatedFor
          rw [Sieve.generate_sieve, ‚Üê Sieve.pullbackArrows_comm, Cover.pullbackArrows_ofArrows]
          exact (Cover.pullbackCover' ùí∞V f).generate_ofArrows_mem_grothendieckTopology
        ¬∑ rintro - - - - ‚ü®i‚ü© ‚ü®j‚ü©
          refine ‚ü®.ofArrows _ (pullback (ùí∞V.map i) (ùí∞V.map j)).affineCover.map, ?_, ?_‚ü©
          ¬∑ exact hzar.isSheafFor _ _
              (Cover.generate_ofArrows_mem_grothendieckTopology _ _) |>.isSeparatedFor
          ¬∑ rintro - - ‚ü®k‚ü©
            rw [‚Üê Sieve.pullbackArrows_comm, ‚Üê Presieve.ofArrows_pullback,
              ‚Üê Presieve.isSeparatedFor_iff_generate]
            refine (this _ ((ùí±.cover.pullbackCover' f).pullbackCover' _) inferInstance
              ‚ü®fun l ‚Ü¶ ?_, hfin‚ü©).isSeparatedFor
            exact .of_isIso (pullbackLeftPullbackSndIso (ùí±.map l) f _).hom
        ¬∑ rintro - - ‚ü®i‚ü©
          rw [‚Üê Sieve.pullbackArrows_comm, ‚Üê Presieve.ofArrows_pullback,
            ‚Üê Presieve.isSheafFor_iff_generate]
          let ùí∞' := (ùí±.cover.pullbackCover' f).pullbackCover' (ùí∞V.map i)
          refine this _ ùí∞' inferInstance
            ‚ü®fun j ‚Ü¶ .of_isIso (pullbackLeftPullbackSndIso (ùí±.map j) f (ùí∞V.map i)).hom, hfin‚ü©
      refine f.isSheafFor ?_ fun f ‚Ü¶ (H _ f).isSeparatedFor
      exact this _ _ inferInstance ‚ü®fun i ‚Ü¶ inferInstanceAs <| IsAffine (Spec _), hfin‚ü©
    obtain ‚ü®_, _‚ü© := hùí∞
    let ùí∞' := ùí∞.sigma
    rw [‚Üê Scheme.Cover.isSheafFor_sigma_iff hzar, Scheme.Cover.ofArrows_of_unique]
    have : IsAffine (ùí∞.sigma.obj default) := by dsimp; infer_instance
    let f : Spec _ ‚ü∂ Spec R := (ùí∞.sigma.obj default).isoSpec.inv ‚â´ ùí∞.sigma.map default
    obtain ‚ü®œÜ, hœÜ‚ü© := Spec.map_surjective f
    rw [isSheafFor_iff_of_iso _ (Spec.map œÜ) (ùí∞.sigma.obj default).isoSpec hzar (by simp [hœÜ, f])]
    refine hff _ ?_ ?_
    ¬∑ simpa only [hœÜ, f] using IsLocalAtSource.comp (ùí∞.sigma.map_prop _) _
    ¬∑ simp only [hœÜ, f, Cover.sigma_J, PUnit.default_eq_unit, Cover.sigma_obj, Cover.sigma_map, f]
      infer_instance

lemma isSheaf_fpqcTopology_iff (F : Scheme.{u}·µí·µñ ‚•§ Type*) :
    Presieve.IsSheaf fpqcTopology F ‚Üî
      Presieve.IsSheaf Scheme.zariskiTopology F ‚àß
        ‚àÄ {R S : CommRingCat.{u}} (f : R ‚ü∂ S) (_ : f.hom.Flat) (_ : Surjective (Spec.map f)),
          Presieve.IsSheafFor F (Presieve.singleton (Spec.map f)) := by
  rw [isSheaf_qcTopology_iff]
  congr!
  exact HasRingHomProperty.Spec_iff

lemma effectiveEpi_of_flat {R S : CommRingCat.{u}} (f : R ‚ü∂ S) (hf : f.hom.Flat)
    (hs : Surjective (Spec.map f)) :
    EffectiveEpi (Spec.map f) := by
  constructor
  constructor
  refine ‚ü®?_, ?_, ?_‚ü©
  ¬∑ sorry
  ¬∑ sorry
  ¬∑ sorry

/-- The fpqc topology is subcanonical. -/
instance : fpqcTopology.Subcanonical := by
  refine .of_isSheaf_yoneda_obj _ fun X ‚Ü¶ ?_
  rw [isSheaf_fpqcTopology_iff (yoneda.obj X)]
  refine ‚ü®?_, ?_‚ü©
  ¬∑ exact GrothendieckTopology.Subcanonical.isSheaf_of_isRepresentable (yoneda.obj X)
  ¬∑ intro R S f hf hs
    revert X
    rw [‚Üê Presieve.EffectiveEpimorphic.iff_forall_isSheafFor_yoneda,
      Sieve.effectiveEpimorphic_singleton]
    exact effectiveEpi_of_flat _ hf hs

/-- A quasi-compact flat cover is an effective epimorphism family. -/
lemma Scheme.Cover.effectiveEpiFamily_of_quasiCompact {X : Scheme.{u}} (ùí∞ : X.Cover @Flat)
    [ùí∞.QuasiCompact] : EffectiveEpiFamily ùí∞.obj ùí∞.map :=
  -- immediate consequence of fqpc subcanonical
  sorry

end AlgebraicGeometry
