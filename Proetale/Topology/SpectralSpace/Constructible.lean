/-
Copyright (c) 2025 Jiedong Jiang, Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jiedong Jiang, Christian Merten
-/
import Proetale.Mathlib.Topology.Inseparable
import Mathlib.Topology.Spectral.Basic
import Mathlib.Topology.JacobsonSpace
import Mathlib.Data.Set.Card

/-!
# Constructible topology

In this file we define the constructible topology on a topological space. This is the topology
generated by compact open subsets and their complements.
-/

variable {X : Type*} [TopologicalSpace X]

/-- The constructible topology on a topological space `X` has as a subbasis
the open and compact sets of `X` and their complements. -/
def constructibleTopology (X : Type*) [TopologicalSpace X] : TopologicalSpace X :=
  .generateFrom ({ s | IsOpen s âˆ§ IsCompact s } âˆª { s | IsClosed s âˆ§ IsCompact sá¶œ })

/-- A type synonym for `X` that is equipped with the constructible topology of `X`. -/
def WithConstructibleTopology (X : Type*) [TopologicalSpace X] : Type _ :=
  X

instance : TopologicalSpace (WithConstructibleTopology X) :=
  constructibleTopology X

open Topology

lemma IsCompact.isOpen_constructibleTopology_of_isOpen {s : Set X}
    (hs : IsCompact s) (ho : IsOpen s) : IsOpen[constructibleTopology X] s := by
  apply TopologicalSpace.isOpen_generateFrom_of_mem
  simp [ho, hs]

lemma IsCompact.isOpen_constructibleTopology_of_isClosed {s : Set X}
    (hs : IsCompact sá¶œ) (ho : IsClosed s) : IsOpen[constructibleTopology X] s := by
  apply TopologicalSpace.isOpen_generateFrom_of_mem
  simp [ho, hs]

lemma compactSpace_generateFrom_of_compl_mem {X : Type*} [T : TopologicalSpace X]
    (ğ”… : Set (Set X)) (hT : T = TopologicalSpace.generateFrom ğ”…)
    (hğ”… : âˆ€ s âˆˆ ğ”…, sá¶œ âˆˆ ğ”…)
    (h : âˆ€ P âŠ† ğ”…, (âˆ€ Q âŠ† P, Q.Finite â†’ (â‹‚â‚€ Q).Nonempty) â†’ (â‹‚â‚€ P).Nonempty) :
    CompactSpace X := by
  apply compactSpace_generateFrom hT
  intro P hPğ”… hP
  contrapose! hP
  simp_rw [â† Set.nonempty_compl, Set.compl_sUnion] at hP âŠ¢
  apply h
  Â· rintro _ âŸ¨S, hS, rflâŸ©
    exact hğ”… _ (hPğ”… hS)
  Â· intro Q hQP hQ
    specialize @hP (compl '' Q)
    replace hP : Q âŠ† compl '' P â†’ (compl '' Q).Finite â†’ (â‹‚â‚€ Q).Nonempty := by
      simpa only [Set.image_subset_iff, Set.sInter_image, Set.mem_image, Set.iInter_exists,
        Set.biInter_and', Set.iInter_iInter_eq_right, compl_compl, Set.nonempty_iInter,
        Set.mem_iInter, â† compl_involutive.image_eq_preimage_symm] using hP
    exact hP hQP (hQ.image _)

/-- A spectral space is compact in the constructible topology. -/
@[stacks 0901]
instance compactSpace_withConstructibleTopology [SpectralSpace X] :
    CompactSpace (WithConstructibleTopology X) := by
  let ğ”… := { s : Set X | IsOpen s âˆ§ IsCompact s } âˆª { s | IsClosed s âˆ§ IsCompact sá¶œ }
  apply compactSpace_generateFrom_of_compl_mem (T := constructibleTopology X) ğ”… rfl
  Â· intro s hs
    refine (Or.symm hs).imp ?_ (by simp)
    simp_all only [Set.mem_union, Set.mem_setOf_eq, isOpen_compl_iff, and_self, implies_true, ğ”…]
  let ğ’® := {P : Set (Set X) | P âŠ† ğ”… âˆ§ (âˆ€ Q âŠ† P, Q.Finite â†’ (â‹‚â‚€ Q).Nonempty) âˆ§ (â‹‚â‚€ P) = âˆ…}
  suffices ğ’® = âˆ… by
    contrapose! this
    rcases this with âŸ¨P, hPâŸ©
    refine âŸ¨P, hPâŸ©
  by_contra! hğ’®
  obtain âŸ¨s, hsâŸ© := hğ’®
  have := (zorn_subset_nonempty ğ’® ?zorn_condition s hs)
  case zorn_condition =>
    rintro c hcğ’® hc âŸ¨x, hxcâŸ©
    have foo : âˆ€ s âˆˆ c, s âŠ† â‹ƒâ‚€ c := by
      intro S hSc
      exact Set.subset_sUnion_of_subset c S (fun â¦ƒaâ¦„ a â†¦ a) hSc
    refine âŸ¨â‹ƒâ‚€ c, ?_, fooâŸ©
    simp only [Set.mem_setOf_eq, Set.sUnion_subset_iff, ğ’®]
    refine âŸ¨?_, ?_, ?_âŸ©
    Â· grind
    Â· intro a hac ha
      suffices âˆƒ i âˆˆ c, a âŠ† i by
        obtain âŸ¨i, hic, haiâŸ© := this
        exact (hcğ’® hic).2.1 a hai ha
      induction h_card : a.ncard generalizing a with
      | zero =>
        simp_all only [Set.ncard_eq_zero, Set.empty_subset, and_true, Set.finite_empty]
        refine âŸ¨_, hxcâŸ©
      | succ n ih =>
        have : Finite a := ha
        rw [Set.ncard_eq_succ] at h_card
        rcases h_card with âŸ¨z, a, hza, rfl, h_cardâŸ©
        obtain âŸ¨i, hic, haiâŸ© := ih a (by grind) (by exact Set.finite_insert.mp ha) h_card
        have hz : z âˆˆ â‹ƒâ‚€ c := by grind
        simp only [Set.mem_sUnion] at hz
        obtain âŸ¨t, htc, hztâŸ© := hz
        obtain rfl | hit := eq_or_ne i t
        Â· grind
        Â· specialize hc hic htc hit
          grind
    Â· grind
  obtain âŸ¨B, hsB, hBâŸ© := this
  have hBğ’® : B âˆˆ ğ’® := hB.prop
  let B' := {s | s âˆˆ B âˆ§ IsClosed s}
  let Z := â‹‚â‚€ B'
  have hZ_closed : IsClosed Z := isClosed_sInter fun b hb â†¦ hb.2
  have hZ_nonempty : Z.Nonempty := by
    dsimp [Z]
    rw [Set.sInter_eq_iInter]
    apply CompactSpace.iInter_nonempty (fun b â†¦ b.2.2)
    intro s
    dsimp [ğ’®] at hBğ’®
    let s' : Set (Set X) := by classical exact (s.image Subtype.val : Set (Set X))
    have hsB : s' âŠ† B := by
      intro x
      simp only [Finset.coe_image, Set.mem_image, Finset.mem_coe, Subtype.exists,
        exists_and_right, exists_eq_right, forall_exists_index, s']
      grind
    have := hBğ’®.2.1 s' hsB (Finset.finite_toSet _)
    simpa [s'] using this
  by_cases hZ_irred : IsIrreducible Z
  Â· suffices (â‹‚â‚€ B).Nonempty by
      have := hBğ’®.2.2
      simp_all
    have hÎ· := hZ_irred.isGenericPoint_genericPoint hZ_closed
    set Î· := hZ_irred.genericPoint
    refine âŸ¨Î·, ?_âŸ©
    rw [Set.mem_sInter]
    intro i hi
    by_cases hiB' : i âˆˆ B'
    Â· suffices Z âŠ† i from this hÎ·.mem
      apply Set.sInter_subset_of_mem hiB'
    Â· have hi_open : IsOpen i := by grind
      have hi_cmpt : IsCompact i := by grind
      rw [hÎ·.mem_open_set_iff hi_open, Set.inter_comm]
      dsimp [Z]
      rw [Set.sInter_eq_iInter]
      apply hi_cmpt.inter_iInter_nonempty
      Â· exact fun b â†¦ b.2.2
      Â· intro A
        have := hBğ’®.2.1 (insert i (by classical exact (A.image Subtype.val : Set (Set X)))) ?sg1 ?sg2
        case sg1 =>
          intro x
          simp only [Finset.coe_image, Set.mem_insert_iff, Set.mem_image, Finset.mem_coe,
            Subtype.exists, exists_and_right, exists_eq_right]
          grind
        case sg2 =>
          classical
          exact Set.toFinite (insert i (Finset.image Subtype.val A))
        convert this using 1
        simp
  Â· unfold IsIrreducible IsPreirreducible  at hZ_irred
    simp only [hZ_nonempty, true_and, not_forall] at hZ_irred
    rcases hZ_irred with âŸ¨Uâ‚, Uâ‚‚, hUâ‚, hUâ‚‚, hUâ‚Z, hUâ‚‚Z, hUâ‚â‚‚âŸ©
    rw [Set.not_nonempty_iff_eq_empty, â† Set.subset_empty_iff] at hUâ‚â‚‚
    obtain âŸ¨xâ‚, hxâ‚âŸ© : âˆƒ xâ‚ âˆˆ Uâ‚, xâ‚ âˆˆ Z âˆ§ xâ‚ âˆ‰ Uâ‚‚ := by
      obtain âŸ¨x, hxâŸ© := hUâ‚Z
      -- on `4.24.0-rc1` this was `grind`
      use x, hx.2, hx.1
      intro hâ‚‚
      exact hUâ‚â‚‚ âŸ¨hx.1, hx.2, hâ‚‚âŸ©
    obtain âŸ¨xâ‚‚, hxâ‚‚âŸ© : âˆƒ xâ‚‚ âˆˆ Uâ‚‚, xâ‚‚ âˆˆ Z âˆ§ xâ‚‚ âˆ‰ Uâ‚ := by
      obtain âŸ¨x, hxâŸ© := hUâ‚‚Z
      -- on `4.24.0-rc1` this was `grind`
      use x, hx.2, hx.1
      intro hâ‚
      exact hUâ‚â‚‚ âŸ¨hx.1, hâ‚, hx.2âŸ©
    have psp_X : PrespectralSpace X := inferInstance
    rw [prespectralSpace_iff] at psp_X
    rw [psp_X.isOpen_iff] at hUâ‚ hUâ‚‚
    obtain âŸ¨Wâ‚, hWâ‚âŸ© := hUâ‚ xâ‚ hxâ‚.1
    obtain âŸ¨Wâ‚‚, hWâ‚‚âŸ© := hUâ‚‚ xâ‚‚ hxâ‚‚.1
    have hWâ‚' : Wâ‚ âˆ© (Z \ Uâ‚) âŠ† âˆ… := by grind
    have hWâ‚‚' : Wâ‚‚ âˆ© (Z \ Uâ‚‚) âŠ† âˆ… := by grind
    let Yâ‚ := Wâ‚á¶œ
    let Yâ‚‚ := Wâ‚‚á¶œ
    have hYâ‚_cl : IsClosed Yâ‚ := by dsimp [Yâ‚]; simpa using hWâ‚.1.1
    have hYâ‚‚_cl : IsClosed Yâ‚‚ := by dsimp [Yâ‚‚]; simpa using hWâ‚‚.1.1
    have hYâ‚ : Yâ‚ âˆˆ ğ”… := by
      right
      dsimp [Yâ‚]
      simp only [isClosed_compl_iff, compl_compl, hWâ‚.1.1, hWâ‚.1.2, true_and]
    have hYâ‚‚ : Yâ‚‚ âˆˆ ğ”… := by
      right
      dsimp [Yâ‚‚]
      simp only [isClosed_compl_iff, compl_compl, hWâ‚‚.1.1, hWâ‚‚.1.2, true_and]
    have hYâ‚B : insert Yâ‚ B âˆ‰ ğ’® := by
      intro hYâ‚B
      have : insert Yâ‚ B âŠ† B := hB.le_of_ge hYâ‚B (Set.subset_insert Yâ‚ B)
      rw [Set.insert_subset_iff] at this
      grind
    have hYâ‚‚B : insert Yâ‚‚ B âˆ‰ ğ’® := by
      intro hYâ‚‚B
      have : insert Yâ‚‚ B âŠ† B := hB.le_of_ge hYâ‚‚B (Set.subset_insert Yâ‚‚ B)
      rw [Set.insert_subset_iff] at this
      grind
    have hYâ‚_inter_B : Yâ‚ âˆ© â‹‚â‚€ B = âˆ… := by grind
    have hYâ‚‚_inter_B : Yâ‚‚ âˆ© â‹‚â‚€ B = âˆ… := by grind
    dsimp [ğ’®] at hYâ‚B hYâ‚‚B
    simp only [Set.insert_subset_iff, hYâ‚, hBğ’®.1, and_self, Set.sInter_insert, hYâ‚_inter_B,
      and_true, true_and, not_forall, Set.not_nonempty_iff_eq_empty, hYâ‚‚, hYâ‚‚_inter_B] at hYâ‚B hYâ‚‚B
    rcases hYâ‚B with âŸ¨Aâ‚, hAâ‚, hAâ‚', hAâ‚''âŸ©
    rcases hYâ‚‚B with âŸ¨Aâ‚‚, hAâ‚‚, hAâ‚‚', hAâ‚‚''âŸ©
    have : Z âŠ† Yâ‚ âˆª Yâ‚‚ := by
      -- on `4.24.0-rc1` this was `grind`
      intro z hz
      by_contra! hc
      simp only [Set.mem_union, Set.mem_compl_iff, not_or, not_not, Yâ‚, Yâ‚‚] at hc
      exact hUâ‚â‚‚ âŸ¨hz, hWâ‚.2.2 hc.1, hWâ‚‚.2.2 hc.2âŸ©
    have : Z âˆ© â‹‚â‚€ ((Aâ‚ \ {Yâ‚}) âˆª (Aâ‚‚ \ {Yâ‚‚})) = âˆ… := by
      grind
    rw [â† Set.not_nonempty_iff_eq_empty] at this
    have H' : âˆ€ A : Set (Set X), A âŠ† {U | IsOpen U âˆ§ IsCompact U} â†’ A.Finite â†’ IsCompact (â‹‚â‚€ A) := by
      intro A hA hA_fin
      induction h_card : A.ncard generalizing A with
      | zero =>
        simp_all only [Set.mem_setOf_eq, Set.subset_empty_iff, Set.ncard_eq_zero, Set.sInter_empty,
          Set.empty_subset, Set.finite_empty]
        exact CompactSpace.isCompact_univ
      | succ n ih =>
        have : Finite A := hA_fin
        rw [Set.ncard_eq_succ] at h_card
        rcases h_card with âŸ¨S, A, hSA, rfl, h_cardâŸ©
        simp only [Set.sInter_insert]
        specialize ih A ((Set.subset_insert S A).trans hA) (by apply hA_fin.subset (Set.subset_insert S A)) h_card
        have := hA (Set.mem_insert S A)
        refine QuasiSeparatedSpace.inter_isCompact _ _ this.1 this.2 ?_ ih
        apply Set.Finite.isOpen_sInter
        Â· apply hA_fin.subset
          grind
        Â· grind
    have H : âˆ€ A, A âŠ† B â†’ A.Finite â†’ IsCompact (â‹‚â‚€ A) := by
      intro A hA hA_fin
      let Ao := {U | U âˆˆ A âˆ§ IsOpen U}
      let Ac := {Z | Z âˆˆ A âˆ§ IsClosed Z}
      have hAoc : Ao âˆª Ac = A := by
        apply subset_antisymm
        Â· grind
        Â· intro x hxA
          have : x âˆˆ ğ”… := hBğ’®.1 (hA hxA)
          apply this.imp <;> grind
      rw [â† hAoc, Set.sInter_union]
      refine IsCompact.inter_right (H' Ao ?_ (hA_fin.subset (by grind))) (isClosed_sInter (by grind))
      intro s hs
      have hğ”…_cmpt : âˆ€ s âˆˆ ğ”…, IsCompact s := by
        rintro s (hs|hs)
        Â· exact hs.2
        Â· exact hs.1.isCompact
      refine âŸ¨hs.2, hğ”…_cmpt _ ?_âŸ©
      grind
    suffices âˆ€ A, A âŠ† B â†’ A.Finite â†’ (Z âˆ© â‹‚â‚€ A).Nonempty by
      specialize this ((Aâ‚ \ {Yâ‚}) âˆª (Aâ‚‚ \ {Yâ‚‚}))
        (by simp only [Set.union_subset_iff]; grind)
        (hAâ‚'.diff.union hAâ‚‚'.diff)
      contradiction
    intro A hA hA_fin
    dsimp [Z]
    rw [Set.sInter_eq_iInter, Set.inter_comm]
    apply (H A hA hA_fin).inter_iInter_nonempty
    Â· exact fun b â†¦ b.2.2
    Â· intro F
      have := hBğ’®.2.1 (A âˆª (by classical exact (F.image Subtype.val : Set (Set X))))
      specialize this (by simp only [Finset.coe_image, Set.union_subset_iff, Set.image_subset_iff]; grind)
      specialize this (by simp only [Finset.coe_image, Set.finite_union, hA_fin, true_and]; exact Set.toFinite (Subtype.val '' â†‘F))
      convert this
      ext
      simp only [Set.iInter_coe_set, Set.mem_inter_iff, Set.mem_sInter, Set.mem_iInter,
        Finset.coe_image, Set.mem_union, Set.mem_image, Finset.mem_coe, Subtype.exists,
        exists_and_right, exists_eq_right]
      grind

/-- If `s` is closed in the constructible topology and `x` is in the closure of `s`, then
it is the specialization of a point in `s`. -/
@[stacks 0903 "(1)"]
lemma exists_specializes_of_isClosed_constructibleTopology_of_mem_closure [SpectralSpace X]
    {s : Set X} (hs : IsClosed[constructibleTopology X] s) {x : X} (hx : x âˆˆ closure s) :
    âˆƒ y âˆˆ s, y â¤³ x :=
  sorry

/-- If `s` is closed in the constructible topology and stable under specialization, it is closed. -/
@[stacks 0903 "(2)"]
lemma IsClosed.of_isClosed_constructibleTopology [SpectralSpace X] {s : Set X}
    (hs : IsClosed[constructibleTopology X] s) (h : StableUnderSpecialization s) :
    IsClosed s := by
  rw [â† closure_subset_iff_isClosed]
  intro x hx
  obtain âŸ¨y, hy, hxâŸ© :=
    exists_specializes_of_isClosed_constructibleTopology_of_mem_closure hs hx
  exact h hx hy

@[stacks 0905 "(6) â†’ (1)"]
theorem SpectralSpace.t2Space_of_isClosed_singleton [SpectralSpace X]
    (h : âˆ€ x : X, IsClosed ({x} : Set X)) : T2Space X :=
  sorry

@[stacks 0905 "(6) â†’ (1)"]
theorem SpectralSpace.totallyDisconnectedSpace_of_isClosed_singleton [SpectralSpace X]
    (h : âˆ€ x : X, IsClosed ({x} : Set X)) : TotallyDisconnectedSpace X :=
  sorry
-- use `isTotallyDisconnected_of_isClopen_set`
-- use `exists_specializes_of_isClosed_constructibleTopology_of_mem_closure,
-- IsClosed.of_isClosed_constructibleTopology`
